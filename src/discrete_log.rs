use super::prelude::*;
use super::wrapper::*;
use super::square_multiply::abs_square_and_multiply;
use super::eea::signed_eea;

use std::hash::Hash;
use std::collections::HashMap;

///
/// Computes the discrete logarithm of value w.r.t base in the monoid given by
/// op and identity. The parameter `base_order` is only required to be a bound
/// on the size of the discrete logarithm, but in many use cases it will be the
/// order of the base in the monoid.
/// 
pub fn baby_giant_step<T, F, I>(value: T, base: &T, base_order: &RingElWrapper<I>, op: F, identity: T) -> Option<RingElWrapper<I>> 
    where F: Fn(T, T) -> T, T: Clone + Hash + Eq, I: IntegerRing
{
    let n = base_order.ring().root_floor(&base_order, 2) + 1;
    let mut giant_steps = HashMap::new();
    let giant_step = abs_square_and_multiply(base, &n, n.ring(), |a, b| op(a, b), |a, b| op(a.clone(), b.clone()), identity.clone());
    let mut current = identity;
    for j in n.ring().zero()..n.clone() {
        giant_steps.insert(current.clone(), j);
        current = op(current, giant_step.clone());
    }
    current = value;
    for i in n.ring().zero()..n.clone() {
        if let Some(j) = giant_steps.get(&current) {
            return Some(j * n - i);
        }
        current = op(current, base.clone());
    }
    return None;
}

///
/// Computes the coefficients of a linear combination of the given value in terms of
/// the base elements in the monoid given by op and identity. The parameter `base_order`
/// is only required to be a bound on the order of those coefficients, but in most use
/// cases, it will be the order of the base elements.
/// 
pub fn baby_giant_step_2d<T, F, I>(value: T, base: (&T, &T), base_order: (&RingElWrapper<I>, &RingElWrapper<I>), op: F, identity: T) -> Option<(RingElWrapper<I>, RingElWrapper<I>)> 
    where F: Fn(T, T) -> T, T: Clone + Hash + Eq, I: IntegerRing
{
    let n1 = base_order.0.ring().root_floor(&base_order.0, 2) + 1;
    let n2 = base_order.1.ring().root_floor(&base_order.1, 2) + 1;
    let mut giant_steps = HashMap::new();
    let giant_step1 = abs_square_and_multiply(base.0, &n1, n1.ring(), |a, b| op(a, b), |a, b| op(a.clone(), b.clone()), identity.clone());
    let giant_step2 = abs_square_and_multiply(base.1, &n2, n2.ring(), |a, b| op(a, b), |a, b| op(a.clone(), b.clone()), identity.clone());
    let mut current1 = identity;
    for k in n1.ring().zero()..n1.clone() {
        let mut current2 = current1.clone();
        for l in n2.ring().zero()..n2.clone() {
            giant_steps.insert(current2.clone(), (k.clone(), l));
            current2 = op(current2, giant_step2.clone());
        }
        current1 = op(current1, giant_step1.clone());
    }
    current1 = value;
    for i in n1.ring().zero()..n1.clone() {
        let mut current2 = current1.clone();
        for j in n2.ring().zero()..n2.clone() {
            if let Some((k, l)) = giant_steps.get(&current2) {
                return Some((k * n1 - i, l * n2 - j));
            }
            current2 = op(current2, base.1.clone());
        }
        current1 = op(current1, base.0.clone());
    }
    return None;
}

fn power_p_discrete_log<T, F, I>(value: T, p_e_base: &T, p: &RingElWrapper<I>, e: u32, op: F, identity: T) -> Option<RingElWrapper<I>> 
    where F: Fn(T, T) -> T, T: Clone + Hash + Eq + std::fmt::Debug, I: IntegerRing
{
    let pow = |x: &T, e: &RingElWrapper<I>| abs_square_and_multiply(x, e, e.ring(), |a, b| op(a, b), |a, b| op(a.clone(), b.clone()), identity.clone());
    let p_base = pow(p_e_base, &p.pow(e - 1));
    debug_assert_ne!(p_base, identity);
    debug_assert_eq!(pow(&p_base, p), identity);
    let mut fill_log = p.ring().zero();
    let mut current = value;
    for i in 0..e {
        let log = baby_giant_step(pow(&current, &p.pow(e - i - 1)), &p_base, &p, &op, identity.clone())?;
        let p_i = p.pow(i);
        let fill = (p - log) * p_i;
        current = op(current, pow(p_e_base, &fill));
        fill_log += fill;
    }
    return Some(p.pow(e) - fill_log);
}

///
/// Computes x such that `x = a mod p` and `x = b mod q`. Requires that p and q are coprime.
/// 
fn crt<I>(a: RingElWrapper<I>, b: RingElWrapper<I>, p: &RingElWrapper<I>, q: &RingElWrapper<I>) -> RingElWrapper<I>
    where I: IntegerRing
{
    let (s, t, d) = signed_eea(p.clone(), q.clone(), &p.ring());
    assert!(d == 1 || d == -1);
    return a * t * q + b * s * p;
}

///
/// Computes the discrete logarithm of value w.r.t the given base in the monoid given by op and identity.
/// It is required that `order` is the order of the base element and this is finite. If the given value is
/// not contained in the submonoid generated by the base element, then None is returned.
/// 
pub fn discrete_log<T, F, I>(value: T, base: &T, order: &RingElWrapper<I>, op: F, identity: T) -> Option<RingElWrapper<I>> 
    where F: Fn(T, T) -> T, T: Clone + Hash + Eq + std::fmt::Debug, I: IntegerRing + UfdInfoRing
{
    let pow = |x: &T, e: &RingElWrapper<I>| abs_square_and_multiply(x, e, e.ring(), |a, b| op(a, b), |a, b| op(a.clone(), b.clone()), identity.clone());
    debug_assert!(pow(&base, &order) == identity);
    let mut current_log = order.ring().one();
    let mut current_size = order.ring().one();
    for (p, e) in order.clone().factor() {
        let size = p.pow(e as u32);
        let power = order / &size;
        let log = power_p_discrete_log(
            pow(&value, &power), 
            &pow(&base, &power), 
            &p,
            e as u32, 
            &op, 
            identity.clone()
        )?;
        current_log = crt(log, current_log, &size, &current_size);
        current_size *= size;
        current_log = current_log % &current_size;
    }
    return Some(current_log);
}

#[cfg(test)]
use super::fq::zn_small::*;

#[test]
fn test_baby_giant_step() {
    let ring = i64::RING;
    assert_eq!(Some(ring.bind_by_value(6)), baby_giant_step::<_, _, StaticRing<i64>>(6, &1, &ring.bind_by_value(20), |a, b| a + b, 0));
}

#[test]
fn test_baby_giant_step_2d() {
    let ring = i64::RING;
    assert_eq!(
        Some((ring.bind_by_value(13), ring.bind_by_value(6))), 
        baby_giant_step_2d::<_, _, StaticRing<i64>>(
            (13, 12), 
            (&(1, 0), &(0, 2)), 
            (&ring.bind_by_value(20), &ring.bind_by_value(20)), 
            |(a1, a2), (b1, b2)| (a1 + b1, a2 + b2), 
            (0,0)
        )
    );
}

#[test]
fn test_power_p_discrete_log() {
    let ring = i64::RING;
    assert_eq!(Some(ring.bind_by_value(6)), power_p_discrete_log(
        ZnEl::<81>::project(6), 
        &ZnEl::project(1),
        &ring.bind_by_value(3), 
        4, 
        |a, b| a + b, 
        ZnEl::project(0),
    ));
}

#[test]
fn test_discrete_log() {
    let ring = i64::RING;
    assert_eq!(Some(ring.bind_by_value(78)), discrete_log(
        ZnEl::<132>::project(78), 
        &ZnEl::project(1),
        &ring.bind_by_value(132), 
        |a, b| a + b, 
        ZnEl::project(0),
    ));
}